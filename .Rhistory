#' @export
#'
f.top_orderMAT <- function(adj.matrix, treatment=NULL, multivariate.variables=NULL) {
# Number of nodes
n <- nrow(adj.matrix)
# Initialize in-degree array
in_degree <- rowSums(adj.matrix)
# Initialize queue for nodes with in-degree 0
queue <- which(in_degree == 0)
if (!is.null(treatment)) {
# reorder the queue such that treatment is always at the end
queue <- treatment.queue(adj.matrix, queue, treatment)
}
# Initialize result list for topological order
top_order <- vector("numeric", n)
order_index <- 1
while (length(queue) > 0) {
# Dequeue a node
node <- queue[1]
queue <- queue[-1]
# Add node to topological order
top_order[order_index] <- node
order_index <- order_index + 1
# Update in-degree of adjacent nodes and enqueue nodes with in-degree 0
for (adj_node in which(adj.matrix[, node] != 0)) {
in_degree[adj_node] <- in_degree[adj_node] - 1
if (in_degree[adj_node] == 0) {
queue <- c(queue, adj_node)
if (!is.null(treatment)) {
# reorder the queue such that treatment is always at the end
queue <- treatment.queue(adj.matrix, queue, treatment)
}
}
}
}
# Check for cycles
if (order_index <= n) {
stop("The graph contains a cycle. Topological ordering not possible. Ordering is only available for directed acyclic graphs (DAGs).")
}
order <- rownames(adj.matrix)[top_order]
if (!is.null(multivariate.variables)) { # if multivariate variables are provided, replace the variable names in the order vector with it's individual component
for (var_name in names(multivariate.variables)) {
replacements <- multivariate.variables[[var_name]]
if (var_name %in% order) {
order <- insert(order, which(order == var_name), replacements)
} # end of if condition
} # end of for loop
}
return(order)
}
f.top_order(graph,'A',list(M=c('M1','M2')))
##############################################################################
# Replace element in a specific position of vector A with another vector B
##############################################################################
insert <- function(vec, pos, value) {
c(vec[1:(pos-1)], value, vec[(pos+1):length(vec)])
}
f.top_order(graph,'A',list(M=c('M1','M2')))
?replace
NPS.TMLE.a <- function(a,data,vertices, di_edges, bi_edges, treatment, outcome, multivariate.variables,
superlearner.seq = F, # whether run superlearner for sequential regression
superlearner.Y=F, # whether run superlearner for outcome regression
superlearner.A=F, # whether run superlearner for propensity score
superlearner.M=F, # whether run superlearner for estimating densratio for M using bayes method
superlearner.L=F, # whether run superlearner for estimating densratio for L using bayes method
crossfit=F, K=5,
ratio.method.L="bayes", # method for estimating the density ratio associated with M
ratio.method.M="bayes", # method for estimating the density ratio associated with L
lib.seq = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for sequential regression
lib.L = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for density ratio estimation via bayes rule for variables in L
lib.M = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for density ratio estimation via bayes rule for variables in M
lib.Y = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for outcome regression
lib.A = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for propensity score
formulaY="Y ~ .", formulaA="A ~ .", # regression formula for outcome regression and propensity score if superlearner is not used
linkY_binary="logit", linkA="logit", # link function for outcome regression and propensity score if superlearner is not used
n.iter=500, cvg.criteria=0.01,
truncate_lower=0, truncate_upper=1){
# attach(data, warn.conflicts=FALSE)
n <- nrow(data)
a0 <- a
a1 <- 1-a
# make a graph object
graph <- make.graph(vertices=vertices, bi_edges=bi_edges, di_edges=di_edges)
vertices <- graph$vertices
di_edges <- graph$di_edges
bi_edges <- graph$bi_edges
# return topological ordering
tau <- f.top_order(graph, treatment)
tau.df <- data.frame(tau=tau, order = 1:length(tau))
# Get set C, M, L
setCML <- CML(graph, treatment) # get set C, M, L
C <- setCML$C # everything comes before the treatment following topological order tau
L <- setCML$L # variables within the district of treatment and comes after the treatment (including the treatment itself) following topological order tau
M <- setCML$M # everything else
# re-order vertices according to their topological order in tau
C <- rerank(C, tau) # re-order vertices in C according to their topological order in tau
L <- rerank(L, tau) # re-order vertices in L according to their topological order in tau
L.removedA <- L[L!=treatment] # remove treatment from L
M <- rerank(M, tau) # re-order vertices in M according to their topological order in tau
# Variables
A <- data[,treatment] # treatment
Y <- data[,outcome] # outcome
##################################################################
## TMLE initialization for sequential regression based estimator
##################################################################
source("R/NPS-01-initial-nuisance-estimate.R")
##################################################################
#################### One-step estimator ##########################
##################################################################
source("R/NPS-02-onestep-estimator.R")
##################################################################
#################### Sequential regression based TMLE ############
##################################################################
source("R/NPS-03-tmle-estimator.R")
return(list(TMLE=tmle.out,Onestep=onestep.out))
}
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'), bi_edges=list(c('A','Y')), di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')), treatment='A', outcome='Y')
##############################################################################
# Replace element in a specific position of vector A with vector under
##############################################################################
replace.vector <- function(vec, multivariate.variables=NULL) {
if (!is.null(multivariate.variables)) { # if multivariate variables are provided, replace the variable names in the order vector with it's individual component
for (var_name in names(multivariate.variables)) {
replacements <- multivariate.variables[[var_name]]
if (var_name %in% vec) {
vec <- insert(vec, which(vec == var_name), replacements)
} # end of if condition
} # end of for loop
}
return(vec)
}
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
NPS.TMLE.a <- function(a,data,vertices, di_edges, bi_edges, treatment, outcome, multivariate.variables,
superlearner.seq = F, # whether run superlearner for sequential regression
superlearner.Y=F, # whether run superlearner for outcome regression
superlearner.A=F, # whether run superlearner for propensity score
superlearner.M=F, # whether run superlearner for estimating densratio for M using bayes method
superlearner.L=F, # whether run superlearner for estimating densratio for L using bayes method
crossfit=F, K=5,
ratio.method.L="bayes", # method for estimating the density ratio associated with M
ratio.method.M="bayes", # method for estimating the density ratio associated with L
lib.seq = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for sequential regression
lib.L = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for density ratio estimation via bayes rule for variables in L
lib.M = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for density ratio estimation via bayes rule for variables in M
lib.Y = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for outcome regression
lib.A = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for propensity score
formulaY="Y ~ .", formulaA="A ~ .", # regression formula for outcome regression and propensity score if superlearner is not used
linkY_binary="logit", linkA="logit", # link function for outcome regression and propensity score if superlearner is not used
n.iter=500, cvg.criteria=0.01,
truncate_lower=0, truncate_upper=1){
# attach(data, warn.conflicts=FALSE)
n <- nrow(data)
a0 <- a
a1 <- 1-a
# make a graph object
graph <- make.graph(vertices=vertices, bi_edges=bi_edges, di_edges=di_edges)
vertices <- graph$vertices
di_edges <- graph$di_edges
bi_edges <- graph$bi_edges
# return topological ordering
tau <- f.top_order(graph, treatment)
tau.df <- data.frame(tau=tau, order = 1:length(tau))
# Get set C, M, L
setCML <- CML(graph, treatment) # get set C, M, L
C <- setCML$C # everything comes before the treatment following topological order tau
L <- setCML$L # variables within the district of treatment and comes after the treatment (including the treatment itself) following topological order tau
M <- setCML$M # everything else
# re-order vertices according to their topological order in tau
C <- rerank(C, tau) # re-order vertices in C according to their topological order in tau
L <- rerank(L, tau) # re-order vertices in L according to their topological order in tau
L.removedA <- L[L!=treatment] # remove treatment from L
M <- rerank(M, tau) # re-order vertices in M according to their topological order in tau
# Variables
A <- data[,treatment] # treatment
Y <- data[,outcome] # outcome
##################################################################
## TMLE initialization for sequential regression based estimator
##################################################################
source("R/NPS-01-initial-nuisance-estimate.R")
##################################################################
#################### One-step estimator ##########################
##################################################################
source("R/NPS-02-onestep-estimator.R")
##################################################################
#################### Sequential regression based TMLE ############
##################################################################
source("R/NPS-03-tmle-estimator.R")
return(list(TMLE=tmle.out,Onestep=onestep.out))
}
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
head(data_fig_4a)
?source
NPS.TMLE.a <- function(a,data,vertices, di_edges, bi_edges, treatment, outcome, multivariate.variables=NULL,
superlearner.seq = F, # whether run superlearner for sequential regression
superlearner.Y=F, # whether run superlearner for outcome regression
superlearner.A=F, # whether run superlearner for propensity score
superlearner.M=F, # whether run superlearner for estimating densratio for M using bayes method
superlearner.L=F, # whether run superlearner for estimating densratio for L using bayes method
crossfit=F, K=5,
ratio.method.L="bayes", # method for estimating the density ratio associated with M
ratio.method.M="bayes", # method for estimating the density ratio associated with L
lib.seq = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for sequential regression
lib.L = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for density ratio estimation via bayes rule for variables in L
lib.M = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for density ratio estimation via bayes rule for variables in M
lib.Y = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for outcome regression
lib.A = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for propensity score
formulaY="Y ~ .", formulaA="A ~ .", # regression formula for outcome regression and propensity score if superlearner is not used
linkY_binary="logit", linkA="logit", # link function for outcome regression and propensity score if superlearner is not used
n.iter=500, cvg.criteria=0.01,
truncate_lower=0, truncate_upper=1){
# attach(data, warn.conflicts=FALSE)
n <- nrow(data)
a0 <- a
a1 <- 1-a
# make a graph object
graph <- make.graph(vertices=vertices, bi_edges=bi_edges, di_edges=di_edges)
vertices <- graph$vertices
di_edges <- graph$di_edges
bi_edges <- graph$bi_edges
# return topological ordering
tau <- f.top_order(graph, treatment)
tau.df <- data.frame(tau=tau, order = 1:length(tau))
# Get set C, M, L
setCML <- CML(graph, treatment) # get set C, M, L
C <- setCML$C # everything comes before the treatment following topological order tau
L <- setCML$L # variables within the district of treatment and comes after the treatment (including the treatment itself) following topological order tau
M <- setCML$M # everything else
# re-order vertices according to their topological order in tau
C <- rerank(C, tau) # re-order vertices in C according to their topological order in tau
L <- rerank(L, tau) # re-order vertices in L according to their topological order in tau
L.removedA <- L[L!=treatment] # remove treatment from L
M <- rerank(M, tau) # re-order vertices in M according to their topological order in tau
# Variables
A <- data[,treatment] # treatment
Y <- data[,outcome] # outcome
##################################################################
## TMLE initialization for sequential regression based estimator
##################################################################
source("R/NPS-01-initial-nuisance-estimate.R", local = T)
##################################################################
#################### One-step estimator ##########################
##################################################################
source("R/NPS-02-onestep-estimator.R", local = T)
##################################################################
#################### Sequential regression based TMLE ############
##################################################################
source("R/NPS-03-tmle-estimator.R")
return(list(TMLE=tmle.out,Onestep=onestep.out))
}
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
library(reticulate)
library(dplyr)
library(SuperLearner)
library(densratio)
library(itertools)
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
vec <- 1:3
vec[1:-1]
vec[1:0]
##############################################################################
# Replace element in a specific position of vector A with another vector B
##############################################################################
insert <- function(vec, pos, value) {
if (pos == 1) { # if the position is the first element of the vector
return(c(value, vec[-1]))
} else if (pos == length(vec)) { # if the position is the last element of the vector
return(c(vec[-length(vec)], value))
} else { # if the position is in the middle of the vector
return(c(vec[1:(pos-1)], value, vec[(pos+1):length(vec)]))
}
}
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
NPS.TMLE.a <- function(a,data,vertices, di_edges, bi_edges, treatment, outcome, multivariate.variables=NULL,
superlearner.seq = F, # whether run superlearner for sequential regression
superlearner.Y=F, # whether run superlearner for outcome regression
superlearner.A=F, # whether run superlearner for propensity score
superlearner.M=F, # whether run superlearner for estimating densratio for M using bayes method
superlearner.L=F, # whether run superlearner for estimating densratio for L using bayes method
crossfit=F, K=5,
ratio.method.L="bayes", # method for estimating the density ratio associated with M
ratio.method.M="bayes", # method for estimating the density ratio associated with L
lib.seq = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for sequential regression
lib.L = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for density ratio estimation via bayes rule for variables in L
lib.M = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for density ratio estimation via bayes rule for variables in M
lib.Y = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for outcome regression
lib.A = c("SL.glm","SL.earth","SL.ranger","SL.mean"), # superlearner library for propensity score
formulaY="Y ~ .", formulaA="A ~ .", # regression formula for outcome regression and propensity score if superlearner is not used
linkY_binary="logit", linkA="logit", # link function for outcome regression and propensity score if superlearner is not used
n.iter=500, cvg.criteria=0.01,
truncate_lower=0, truncate_upper=1){
# attach(data, warn.conflicts=FALSE)
n <- nrow(data)
a0 <- a
a1 <- 1-a
# make a graph object
graph <- make.graph(vertices=vertices, bi_edges=bi_edges, di_edges=di_edges)
vertices <- graph$vertices
di_edges <- graph$di_edges
bi_edges <- graph$bi_edges
# return topological ordering
tau <- f.top_order(graph, treatment)
tau.df <- data.frame(tau=tau, order = 1:length(tau))
# Get set C, M, L
setCML <- CML(graph, treatment) # get set C, M, L
C <- setCML$C # everything comes before the treatment following topological order tau
L <- setCML$L # variables within the district of treatment and comes after the treatment (including the treatment itself) following topological order tau
M <- setCML$M # everything else
# re-order vertices according to their topological order in tau
C <- rerank(C, tau) # re-order vertices in C according to their topological order in tau
L <- rerank(L, tau) # re-order vertices in L according to their topological order in tau
L.removedA <- L[L!=treatment] # remove treatment from L
M <- rerank(M, tau) # re-order vertices in M according to their topological order in tau
# Variables
A <- data[,treatment] # treatment
Y <- data[,outcome] # outcome
##################################################################
## TMLE initialization for sequential regression based estimator
##################################################################
source("R/NPS-01-initial-nuisance-estimate.R", local = T)
##################################################################
#################### One-step estimator ##########################
##################################################################
source("R/NPS-02-onestep-estimator.R", local = T)
##################################################################
#################### Sequential regression based TMLE ############
##################################################################
source("R/NPS-03-tmle-estimator.R", local = T)
return(list(TMLE=tmle.out,Onestep=onestep.out))
}
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
tmp$TMLE$estimated_psi
tmp$Onestep$estimated_psi
insert(c('A','B','C'), 2, 'D')
replace.vector(c('A','B','C'), list(A=c('D','E')))
devtools::use_vignette("introduction")
usethis::use_vignette("introduction")
devtools::install()
?load_all
devtools::install()
library(ADMGtmle)
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
devtools::install()
library(ADMGtmle)
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
devtools::install()
library(ADMGtmle)
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
devtools::install()
devtools::install()
library(devtools)
devtools::install()
library(ADMGtmle)
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
library(ADMGtmle)
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
devtools::check()
devtools::use_build_ignore("R/initiate", escape = TRUE)
usethis::use_build_ignore("R/initiate", escape = TRUE)
devtools::check()
usethis::use_build_ignore("R/initiate", escape = F)
usethis::use_build_ignore("R/initiate.R", escape = F)
getwd()
devtools::check()
devtools::check()
?comb
library(itertools)
?combn
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::use_gpl3_license()
usethis::use_gpl3_license()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
install.packages("roxygen2")
library(roxygen2)
devtools::check()
install.packages("devtools")
library("devtools")
devtools::install_github("klutometis/roxygen")
devtools::check()
library(fdtmle)
?TMLE
devtools::check()
devtools::check()
library(devtools)
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::install()
library(ADMGtmle)
?NPS.TMLE.a
library(ADMGtmle)
tmp <- NPS.TMLE.a(a=1,data=data_fig_4a, vertices=c('A','M','L','Y','X'),
bi_edges=list(c('A','Y')),
di_edges=list(c('X','A'), c('X','M'), c('X','L'),c('X','Y'), c('M','Y'), c('A','M'), c('A','L'), c('M','L'), c('L','Y')),
treatment='A', outcome='Y',
multivariate.variables = list(M=c('M1','M2')))
tmp$TMLE
tmp$TMLE$estimated_psi
tmp$Onestep$estimated_psi
devtools::document()
devtools::install()
library(ADMGtmle)
?NPS.TMLE.a
devtools::install()
library(ADMGtmle)
?NPS.TMLE.a
?NPS.TMLE.a
remove.packages("ADMGtmle")
devtools::install()
library(ADMGtmle)
?NPS.TMLE.a
tools::cleanPackRdb()
tools::vignetteEngine(package = "ADMGtmle", ask = FALSE)
?NPS.TMLE.a
?insert
devtools::document()
devtools::install()
library(ADMGtmle)
?NPS.TMLE.a
?NPS.TMLE.a
?NPS.TMLE.a
library(ADMGtmle)
?make.graph
library(devtools)
devtools::document()
devtools::install()
library(ADMGtmle)
?make.graph
?treatment.queue
?insert
?NPS.TMLE.a
devtools::document()
devtools::install()
library(ADMGtmle)
?make.graph
devtools::document()
devtools::install()
